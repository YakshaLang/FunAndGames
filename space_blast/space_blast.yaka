# All assets from https://www.kenney.nl/assets/
# Code ported to Yaksha based on https://github.com/tashvit/space-blast

import libs.os
import libs.console
import raylib as rl
import raylib.utils
import libs.numbers as num
import libs.perlin
import libs.random

SCENE_TITLE: Const[u8] = 0u8
SCENE_PLAY: Const[u8] = 1u8
SCENE_GAME_OVER: Const[u8] = 2u8
GAME_W: Const[int] = 1920
GAME_H: Const[int] = 1080
STAR_COUNT: Const[int] = 100
ENEMY_COUNT: Const[int] = 20
FPS_TARGET: Const[int] = 60

@onstack
class Star:
    x: int
    y: int
    speed: int
    r: int

@onstack
class Enemy:
    x: int
    y: int
    speed: int
    type: int
    swing: int

@onstack
class Bullet:
    x: int
    y: int

class State:
    frame_count: u64
    seed: u64
    assets: Assets
    player_x: int
    player_y: int
    speed: int
    stars: Array[Tuple[int, int, int, int]]
    enemies: Array[Tuple[int, int, int, int, int]]
    bullets: Array[Tuple[int, int]]
    scene: u8
    player_moving: bool
    player_bullet: Tuple[int, int]
    player_score: int

class Assets:
    loaded: bool
    bg: rl.Color
    white: rl.Color
    player: rl.Texture2D
    enemy1: rl.Texture2D
    enemy2: rl.Texture2D
    enemy3: rl.Texture2D
    enemy4: rl.Texture2D
    enemy5: rl.Texture2D
    meteor: rl.Texture2D
    enemy_laser: rl.Texture2D

def update_stars(s: State) -> None:
    c: int = 0
    while c < STAR_COUNT:
        # y += speed
        s.stars[c][1] += s.stars[c][3]
        # if we are out of the screen recreate the star
        if s.stars[c][1] > GAME_H + 10:
            s.stars[c][1] = -10
            s.stars[c][0] = rl.get_random_value(0, GAME_W)
            s.stars[c][3] = rl.get_random_value(1, 4)
        c += 1

def update_player(s: State) -> None:
    w2: int = cast("int", s.assets.player.width) / 2
    h2: int = cast("int", s.assets.player.height) / 2
    s.player_moving = False
    # User pressed a key -> move the player
    if rl.is_key_down(rl.KEY_W):
        s.player_y -= s.speed
        s.player_moving = True
    if rl.is_key_down(rl.KEY_A):
        s.player_x -= s.speed
        s.player_moving = True
    if rl.is_key_down(rl.KEY_S):
        s.player_y += s.speed
        s.player_moving = True
    if rl.is_key_down(rl.KEY_D):
        s.player_x += s.speed
        s.player_moving = True
    # Ensure that the player width/height is constrained
    # So we cannot go out of the bounds
    if s.player_x <= w2:
        s.player_x = w2
    if s.player_x >= GAME_W - w2:
        s.player_x = GAME_W - w2
    if s.player_y <= h2:
        s.player_y = h2
    if s.player_y >= GAME_H - h2:
        s.player_y = GAME_H - h2
    # Check collisions with enemies
    c: int = 0
    while c < ENEMY_COUNT:
        collide: bool = collides(get_enemy_ship(s, s.enemies[c][2]), s.enemies[c][0], s.enemies[c][1], s.assets.player, s.player_x, s.player_y)
        if collide:
            s.scene = SCENE_GAME_OVER
            break
        c += 1
    # Check collisions with bullets
    c = 0
    while c < ENEMY_COUNT:
        collide: bool = collides(s.assets.enemy_laser, s.bullets[c][0], s.bullets[c][1], s.assets.player, s.player_x, s.player_y)
        if collide:
            s.scene = SCENE_GAME_OVER
            break
        c += 1

def update_enemies(s: State) -> None:
    c: int = 0
    while c < ENEMY_COUNT:
        s.enemies[c][1] += s.enemies[c][3]
        swing: u64 = cast("u64", s.enemies[c][4]) + s.frame_count
        s.enemies[c][0] += s.enemies[c][3] * iif(swing % 60u64 < 30u64, 1, -1)
        if s.enemies[c][1] > GAME_H + 50:
            s.enemies[c][1] = -rl.get_random_value(60, 100)
            s.enemies[c][0] = rl.get_random_value(0, GAME_W)
            s.enemies[c][3] = rl.get_random_value(1, 5)
            s.enemies[c][4] = rl.get_random_value(100, 10000)
        elif swing % 6u64 == 0u64 and s.bullets[c][1] == -999 and s.enemies[c][1] > 5:
            s.bullets[c][0] = s.enemies[c][0] + 32
            s.bullets[c][1] = s.enemies[c][1] + 32

        if s.bullets[c][1] > GAME_H + 50:
            s.bullets[c][0] = -999
            s.bullets[c][1] = -999
        elif s.bullets[c][1] != -999:
            s.bullets[c][1] += 6
        c += 1

def draw_stars(s: State) -> None:
    c: int = 0
    while c < STAR_COUNT:
        star: Tuple[int, int, int, int] = s.stars[c]
        # If the star size is 4 draw a meteor
        if s.stars[c][2] == 4:
            draw_image(s.assets.meteor, star[0], star[1])
        else:
            rl.draw_circle(star[0], star[1], cast("float", star[2]), s.assets.white)
        c += 1

def draw_enemies(s: State) -> None:
    c: int = 0
    while c < ENEMY_COUNT:
        draw_image(get_enemy_ship(s, s.enemies[c][2]), s.enemies[c][0], s.enemies[c][1])
        if s.bullets[c][1] != -999:
            draw_image(s.assets.enemy_laser, s.bullets[c][0], s.bullets[c][1])
        c += 1

def draw_player(s: State) -> None:
    draw_image(s.assets.player, s.player_x, s.player_y)

def game_step(d: utils.Data) -> None:
    s: State = cast("State", d)
    ensure_assets(s)
    rl.begin_drawing()
    rl.clear_background(s.assets.bg)
    # ----------------------------------------------
    # ----------------------------------------------
    if s.scene == SCENE_PLAY:
        update_player(s)
        update_stars(s)
        update_enemies(s)
    draw_stars(s)
    draw_player(s)
    draw_enemies(s)
    if s.scene == SCENE_TITLE:
        if (s.frame_count / 50u64) % 2u64 == 0u64:
            rl.draw_text("Press [space] to start", GAME_W / 2 - 450, GAME_H / 2 - 30, 80, s.assets.white)
        if rl.is_key_down(rl.KEY_SPACE):
            s.scene = SCENE_PLAY
    if s.scene == SCENE_GAME_OVER:
        if (s.frame_count / 50u64) % 2u64 == 0u64:
            rl.draw_text("Game over ", GAME_W / 2 - 200, GAME_H / 2 - 30, 80, s.assets.white)
            rl.draw_text("Press [space] to start", GAME_W / 2 - 450, GAME_H / 2 + 50, 80, s.assets.white)
        if rl.is_key_down(rl.KEY_SPACE):
            s.scene = SCENE_PLAY
            reset_state(s)
    # -----------------------------------------------
    # ----------------------------------------------
    rl.draw_fps(0, 0)
    rl.end_drawing()
    s.frame_count = s.frame_count + 1u64

def init_state() -> State:
    s: State = State()
    s.frame_count = 0u64
    s.assets = Assets()
    s.assets.loaded = False
    s.stars = arrnew("Tuple[int, int, int, int]", STAR_COUNT)
    s.enemies = arrnew("Tuple[int, int, int, int, int]", ENEMY_COUNT)
    s.bullets = arrnew("Tuple[int, int]", ENEMY_COUNT)
    s.seed = random.init_random()
    reset_state(s)
    return s

def reset_state(s: State) -> None:
    s.player_x = GAME_H / 2
    s.player_y = GAME_W / 2
    s.player_bullet[0] = -999
    s.player_bullet[1] = -999

    s.speed = 5
    c: int = 0
    while c < STAR_COUNT:
        s.stars[c][0] = rl.get_random_value(0, GAME_W)
        s.stars[c][1] = rl.get_random_value(0, GAME_H)
        s.stars[c][2] = rl.get_random_value(1, 4)
        s.stars[c][3] = rl.get_random_value(1, 4)
        c += 1
    c = 0
    while c < ENEMY_COUNT:
        s.enemies[c][0] = rl.get_random_value(0, GAME_W)
        s.enemies[c][1] = -rl.get_random_value(60, 100)
        s.enemies[c][2] = rl.get_random_value(1, 5)
        s.enemies[c][3] = rl.get_random_value(1, 5)
        s.enemies[c][4] = rl.get_random_value(100, 10000)
        s.bullets[c][0] = -999
        s.bullets[c][1] = -999
        c += 1

def ensure_assets(s: State) -> None:
    if s.assets.loaded:
        return
    s.assets.bg = rl.color(0, 0, 0, 255)
    s.assets.white = rl.color(255, 255, 255, 255)
    s.assets.player = load_image("playerShip1_blue.png")
    s.assets.enemy1 = load_image("shipBeige_manned.png")
    s.assets.enemy2 = load_image("shipBlue_manned.png")
    s.assets.enemy3 = load_image("shipPink_manned.png")
    s.assets.enemy4 = load_image("shipGreen_manned.png")
    s.assets.enemy5 = load_image("shipYellow_manned.png")
    s.assets.meteor = load_image("meteorGrey_tiny2.png")
    s.assets.enemy_laser = load_image("laserRed03.png")
    s.assets.loaded = True

def del_state(current: utils.Data) -> None:
    s: State = cast("State", current)
    if s.assets.loaded:
        rl.unload_texture(s.assets.player)
        rl.unload_texture(s.assets.enemy1)
        rl.unload_texture(s.assets.enemy2)
        rl.unload_texture(s.assets.enemy3)
        rl.unload_texture(s.assets.enemy4)
        rl.unload_texture(s.assets.enemy5)
        rl.unload_texture(s.assets.enemy_laser)
    del s.enemies
    del s.stars
    del s.assets
    del s

def main() -> int:
    s: State = init_state()
    s.scene = SCENE_TITLE
    rl.init_window(GAME_W, GAME_H, "Space blast")
    utils.run_game_loop(FPS_TARGET, cast("utils.Data", s))
    if not utils.is_hot_reload():
        del_state(cast("utils.Data", s))
    return 0

# ------------ Utilities -----------

def load_image(s: str) -> rl.Texture2D:
    path: str
    if os.is_windows():
        path = "assets\\img\\" + s
    else:
        path = "assets/img/" + s
    console.cyan("Loading texture")
    console.red(" := ")
    console.green(path)
    println("")
    return rl.load_texture(path)

def draw_image(img: rl.Texture2D, x: int, y: int) -> None:
    w: int = cast("int", img.width)
    h: int = cast("int", img.height)
    rl.draw_texture(img, x - w / 2, y - h / 2, rl.color(255, 255, 255, 255))

def rectangle(img: rl.Texture2D, x: int, y: int) -> rl.Rectangle:
    w: int = cast("int", img.width) - 2
    h: int = cast("int", img.height) - 2
    actual_x: float = cast("float", x - w / 2) + 1
    actual_y: float = cast("float", y - h / 2) + 1
    return rl.rectangle(actual_x, actual_y, cast("float", w), cast("float", h))

def collides(img1: rl.Texture2D, x1: int, y1: int, img2: rl.Texture2D, x2: int, y2: int) -> bool:
    return rl.check_collision_recs(rectangle(img1, x1, y1), rectangle(img2, x2, y2))

def get_enemy_ship(s: State, asset: int) -> rl.Texture2D:
    enemy: rl.Texture2D
    if asset == 1:
        enemy = s.assets.enemy1
    if asset == 2:
        enemy = s.assets.enemy2
    if asset == 3:
        enemy = s.assets.enemy3
    if asset == 4:
        enemy = s.assets.enemy4
    if asset == 5:
        enemy = s.assets.enemy5
    return enemy
